<h1>Strings <small>&bull; Capítulo 14</small></h1>


<h2>Bibliotecas</h2> <hr/>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/string.png" alt="string" class="img-responsive" width="300px" height="219px"/>
  <p><small>String &bull; Quão comprida é esta?.</small></p>
</div>

<p>Nosso Lisp é finalmente funcional. Devemos ser capaz de escrever praticamente qualquer função que desejarmos. Podemos criar construções bem complexas usando ela, e mesmo fazer coisas legais que não são possíveis em muitas linguagens pesadas e populares;</p>

<p>Cada vez que atualizamos nosso programa e o rodamos novamente, é chato ter que digitar todas nossas funções. Neste capítulo, vamos adicionar a funcionalidade de carregar código de um arquivo e rodá-lo. Isto vai nos permitir começar a construir uma biblioteca padrão. Ao longo do caminho, vamos também adicionar suporte para comentários no código, strings e impressão.</p>


<h2>Tipo String</h2> <hr/>

<p>Para o usuário carregar um arquivo, teremos que deixá-lo fornecer uma string consistindo do nome do arquivo. Nossa linguagem suporta símbolos, mas ainda não suporta strings, que podem incluir espaços e outros caracteres. Precisamos adicionar este possível tipo <code>lval</code> para especificar os nomes de arquivos que precisamos.</p>

<p>Começamos, como em outros capítulos, adicionando um item ao nosso enum e adicionando um item ao nosso <code>lval</code> para representar o tipo do dado.</p>

<pre><code data-language='c'>enum { LVAL_ERR, LVAL_NUM,   LVAL_SYM, LVAL_STR, 
       LVAL_FUN, LVAL_SEXPR, LVAL_QEXPR };</code></pre>

<pre><code data-language='c'>/* Basico */
long num;
char* err;
char* sym;
char* str;
</code></pre>

<p>A seguir, podemos adicionar uma função para construir <code>lval</code> strings, de maneira similar a como fizemos para construir símbolos.</p>

<pre><code data-language='c'>lval* lval_str(char* s) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_STR;
  v-&gt;str = malloc(strlen(s) + 1);
  strcpy(v-&gt;str, s);
  return v;
}</code></pre>

<p>Também precisamos adicionar os itens relevantes em nossas funções que lidam com <code>lval</code>.</p>

<p>Para <strong>Deleção</strong>...</p>

<pre><code data-language='c'>case LVAL_STR: free(v-&gt;str); break;</code></pre>

<p>Para <strong>Cópia</strong>...</p>

<pre><code data-language='c'>case LVAL_STR: x-&gt;str = malloc(strlen(v-&gt;str) + 1);
  strcpy(x-&gt;str, v-&gt;str); break;</code></pre>

<p>Para <strong>Igualdade</strong>...</p>

<pre><code data-language='c'>case LVAL_STR: return (strcmp(x-&gt;str, y-&gt;str) == 0);</code></pre>

<p>Para <strong>Nome do Tipo</strong>...</p>

<pre><code data-language='c'>case LVAL_STR: return "String";</code></pre>

<p>Para <strong>Impressão</strong>, precisamos fazer um pouco mais. A string que armazenamso internamente é diferente da string que queremos imprimir. Queremos imprimir uma string que um usuário possa digitar na entrada, usando caracteres de escapa como <code>\n</code> para representar uma quebra de linha.</p>

<p>Por isso precisamos escapá-la antes de imprimi-la. Por sorte, podemos usar uma função <code>mpc</code> que fará isso para nós.</p>

<p>Na função de impressão, adicionamos o seguinte...</p>

<pre><code data-language='c'>case LVAL_STR:   lval_print_str(v); break;</code></pre>

<p>Onde...</p>

<pre><code data-language='c'>void lval_print_str(lval* v) {
  /* Faz uma copia da string */
  char* escaped = malloc(strlen(v-&gt;str)+1);
  strcpy(escaped, v-&gt;str);
  /* Passe-a pela funcao de escape */
  escaped = mpcf_escape(escaped);
  /* Imprima-a entre caracteres " */
  printf("\"%s\"", escaped);
  /* libera a string copiada */
  free(escaped);
}</code></pre>


<h2>Lendo Strings</h2> <hr/>

<p>Agora precisamos adicionar suporte a interpretar strings. Como de costume, isto requer primeiro adicionar uma nova regra gramatical chamada <code>string</code> e adicioná-la ao nosso analisador sintático.</p>

<p>A regra que vamos usar que representa uma string vai ser a mesma para as strings em C. Isto quer dizer que uma string é essencialmente uma série de caracteres de escape, ou caracteres normais, entre duas aspas duplas <code>""</code>. Podemos especificar isto como uma expressão regular dentro da nossa string de gramática como segue.</p>

<pre><code>string  : /\"(\\\\.|[^\"])*\"/ ;</code></pre>

<p>Isto parece complicado mas faz bastante sentido quando explicado em partes. Lê-se dessa forma. Uma string é um caractere <code>"</code>, seguido de zero ou mais de, ou uma barra invertida <code>\\</code> seguida de qualquer outro caractere <code>.</code>, ou qualquer coisa que <em>não seja</em> um caractere <code>"</code> (<code>[^\\"]</code>). Finalmente, termina com outro caractere <code>"</code>.</p>

<p>Também precisamos adicionar um caso para lidar com ist na função <code>lval_read</code>.</p>

<pre><code data-language='c'>if (strstr(t-&gt;tag, "string")) { return lval_read_str(t); }</code></pre>

<p>Como a string da entrada é introduzida em forma escapada, precisamos criar uma função <code>lval_read_str</code> que lida com isso. Esta função é um pouco complicada porque ela precisa fazer certas coisas: primeiro ela precisa remover os caracteres <code>"</code> de qualquer lado. A seguir, ela precisa desescapar a string, convertendo sequências de caracteres como <code>\n</code> para os caracteres realmente codificados. Finalmente, precisa criar um novo <code>lval</code> e limpar qualquer coisa que tenha acontecido no meio do caminho.</p>

<pre><code data-language='c'>lval* lval_read_str(mpc_ast_t* t) {
  /* Corta a aspa do final */
  t-&gt;contents[strlen(t-&gt;contents)-1] = '\0';
  /* Copia a string, pulando a primeira aspa */
  char* unescaped = malloc(strlen(t-&gt;contents+1)+1);
  strcpy(unescaped, t-&gt;contents+1);
  /* Passa pela funcao unescape para desescapar */
  unescaped = mpcf_unescape(unescaped);
  /* Constroi um novo lval usando a string */
  lval* str = lval_str(unescaped);
  /* Libera a string e devolve */
  free(unescaped);
  return str;
}</code></pre>

<p>Se isso tudo funcionar, devemos ser capaz de brincar um pouco com strings no prompt. A seguir, vamos adicionar funções que realmente façam uso delas.</p>

<pre><code data-language='lispy'>lispy&gt; "hello"
"hello"
lispy&gt; "hello\n"
"hello\n"
lispy&gt; "hello\""
"hello\""
lispy&gt; head {"hello" "world"}
{"hello"}
lispy&gt; eval (head {"hello" "world"})
"hello"
lispy&gt;</code></pre>


<h2>Comentários</h2> <hr/>

<p>Já que estamos adicionando nova sintaxe para a linguagem, podemos também dar uma olhada em comentários.</p>

<p>Da mesma forma que em C, podemos usar comentários para informar outras pessoas (ou nós mesmos) sobre o que o código está tentando fazer ou por que ele foi escrito. Em C, comentários vão entre <code>/*</code> e <code>*/</code>. Comentários Lisp, por sua vez, começam com <code>;</code> e vão até o fim da linha.</p>

<p>Tentei pesquisar por que Lisps usam <code>;</code> para comentários, mas parece que as origens disso foram perdidas nos nevoeiros do tempo. Eu imagino isso como uma pequena rebelião contra as linguagens imperativas como C e Java, que usam pontos e vírgulas tão descarada e frequentemente para separar/terminar comandos. Comparando a Lisp, todas essas lingagens são apenas comentários.</p>

<p>Então em Lisp, um comentário é definido com um ponto e vírgula <code>;</code> seguido de qualquer número de caracteres que não são caracteres quebra de linha representados ou por <code>\r</code> ou por <code>\n</code>. Podemos adicionar uma outra expressão regular para definir isso.</p>

<pre><code>comment : /;[^\\r\\n]*/ ;</code></pre>

<p>Da mesma forma que com strings, precisamos criar um novo parser e usar isso para atualizar nossa linguagem em <code>mpca_lang</code>. Também precisamos lembrar de adicionar o parser em <code>mpc_cleanup</code>, e atualizar o primeiro argumento inteiro para refletir o novo número de parsers passados.</p>

<p>Nossa gramática final agora se parece com isto.</p>

<pre><code data-language='c'>mpca_lang(MPCA_LANG_DEFAULT,
  "                                              \
    number  : /-?[0-9]+/ ;                       \
    symbol  : /[a-zA-Z0-9_+\\-*\\/\\\\=&lt;&gt;!&amp;]+/ ; \
    string  : /\"(\\\\.|[^\"])*\"/ ;             \
    comment : /;[^\\r\\n]*/ ;                    \
    sexpr   : '(' &lt;expr&gt;* ')' ;                  \
    qexpr   : '{' &lt;expr&gt;* '}' ;                  \
    expr    : &lt;number&gt;  | &lt;symbol&gt; | &lt;string&gt;    \
            | &lt;comment&gt; | &lt;sexpr&gt;  | &lt;qexpr&gt;;    \
    lispy   : /^/ &lt;expr&gt;* /$/ ;                  \
  ",
  Number, Symbol, String, Comment, Sexpr, Qexpr, Expr, Lispy);
</code></pre>

<p>E a função de limpeza agora se parece com isso.</p>

<pre><code data-language='c'>mpc_cleanup(8, 
  Number, Symbol, String, Comment, 
  Sexpr,  Qexpr,  Expr,   Lispy);</code></pre>

<p>Como comentários são somente para programadores lendo o código, nossa função interna para lê-los consiste em apenas ignorá-los. Podemos adicionar uma cláusula para lidar com eles de maneira similar a chaves e parênteses em <code>lval_read</code>.</p>

<pre><code data-language='c'>if (strstr(t-&gt;children[i]-&gt;tag, "comment")) { continue; }</code></pre>

<p>Comentários não serão de muito uso no prompt interativo, mas serão bem úteis para anotar arquivos de código.</p>


<h2>Função Load</h2>

<p>Queremos construir uma função que possa carregar (<em>load</em>) e avaliar um arquivo quando passada uma string com seu nome. Para implementar esta função vamos precisar fazer uso da nossa gramática, já que teremos que ler o conteúdo do arquivo, interpretar e avaliá-la. Nossa função <code>load</code> vai se fiar em nosso <code>mpc_parser*</code> chamado <code>Lispy</code>.</p>

<p>Therefore, just like with functions, we need to forward declare our parser pointers, and place them at the top of the file.</p>

<pre><code data-language='c'>mpc_parser_t* Number; 
mpc_parser_t* Symbol; 
mpc_parser_t* String; 
mpc_parser_t* Comment;
mpc_parser_t* Sexpr;  
mpc_parser_t* Qexpr;  
mpc_parser_t* Expr; 
mpc_parser_t* Lispy;
</code></pre>

<p>Our <code>load</code> function will be just like any other builtin. We need to start by checking that the input argument is a single string. Then we can use the <code>mpc_parse_contents</code> function to read in the contents of a file using a grammar. Just like <code>mpc_parse</code> this parses the contents of a file into some <code>mpc_result</code> object, which is our case is an <em>abstract syntax tree</em> again or an <em>error</em>.</p>

<p>Slightly differently to our command prompt, on successfully parsing a file we shouldn't treat it like one expression. When typing into a file we let users list multiple expressions and evaluate all of them individually. To achieve this behaviour we need to loop over each expression in the contents of the file and evaluate it one by one. If there are any errors we should print them and continue.</p>

<p>If there is a parse error we're going to extract the message and put it into a error <code>lval</code> which we return. If there are no errors the return value for this builtin can just be the empty expression. The full code for this looks like this.</p>

<pre><code data-language='c'>lval* builtin_load(lenv* e, lval* a) {
  LASSERT_NUM("load", a, 1);
  LASSERT_TYPE("load", a, 0, LVAL_STR);
  
  /* Parse File given by string name */
  mpc_result_t r;
  if (mpc_parse_contents(a-&gt;cell[0]-&gt;str, Lispy, &r)) {
    
    /* Read contents */
    lval* expr = lval_read(r.output);
    mpc_ast_delete(r.output);

    /* Evaluate each Expression */
    while (expr-&gt;count) {
      lval* x = lval_eval(e, lval_pop(expr, 0));
      /* If Evaluation leads to error print it */
      if (x-&gt;type == LVAL_ERR) { lval_println(x); }
      lval_del(x);
    }
    
    /* Delete expressions and arguments */
    lval_del(expr);    
    lval_del(a);
    
    /* Return empty list */
    return lval_sexpr();
    
  } else {
    /* Get Parse Error as String */
    char* err_msg = mpc_err_string(r.error);
    mpc_err_delete(r.error);
    
    /* Create new error message using it */
    lval* err = lval_err("Could not load Library %s", err_msg);
    free(err_msg);
    lval_del(a);
    
    /* Cleanup and return error */
    return err;
  }
}</code></pre>


<h2>Command Line Arguments</h2> <hr/>

<p>With the ability to load files, we can take the chance to add in some functionality typical of other programming languages. When file names are given as arguments to the command line we can try to run these files. For example to run a python file one might write <code>python filename.py</code>.</p>

<p>These command line arguments are accessible using the <code>argc</code> and <code>argv</code> variables that are given to <code>main</code>. The <code>argc</code> variable gives the number of arguments, and <code>argv</code> specifies each string. The <code>argc</code> is always set to at least one, where the first argument is always the complete command invoked.</p>

<p>That means if <code>argc</code> is set to <code>1</code> we can invoke the interpreter, otherwise we can run each of the arguments through the <code>builtin_load</code> function.</p>

<pre><code data-language='c'>/* Supplied with list of files */
if (argc &gt;= 2) {

  /* loop over each supplied filename (starting from 1) */
  for (int i = 1; i &lt; argc; i++) {

    /* Argument list with a single argument, the filename */
    lval* args = lval_add(lval_sexpr(), lval_str(argv[i]));

    /* Pass to builtin load and get the result */
    lval* x = builtin_load(e, args);

    /* If the result is an error be sure to print it */
    if (x-&gt;type == LVAL_ERR) { lval_println(x); }
    lval_del(x);
  }
}
</code></pre>

<p>It's now possible to write some basic program and try to invoke it using this method.</p>

<pre><code>lispy example.lspy</code></pre>


<h2>Print Function</h2> <hr/>

<p>If we are running programs from the command line we might want them to output some data, rather than just define functions and other values. We can add a <code>print</code> function to our Lisp which makes use of our existing <code>lval_print</code> function.</p>

<p>This function prints each argument separated by a space and then prints a newline character to finish. It returns the empty expression.</p>

<pre><code data-language='c'>lval* builtin_print(lenv* e, lval* a) {

  /* Print each argument followed by a space */
  for (int i = 0; i &lt; a-&gt;count; i++) {
    lval_print(a-&gt;cell[i]); putchar(' ');
  }

  /* Print a newline and delete arguments */
  putchar('\n');
  lval_del(a);

  return lval_sexpr();
}</code></pre>


<h2>Error Function</h2> <hr/>

<p>We can also make use of strings to add in an error reporting function. This can take as input a user supplied string and provide it as an error message for <code>lval_err</code>.</p>

<pre><code data-language='c'>lval* builtin_error(lenv* e, lval* a) {
  LASSERT_NUM("error", a, 1);
  LASSERT_TYPE("error", a, 0, LVAL_STR);

  /* Construct Error from first argument */
  lval* err = lval_err(a-&gt;cell[0]-&gt;str);

  /* Delete arguments and return */
  lval_del(a);
  return err;
}</code></pre>

<p>The final step is to register these as builtins. Now finally we can start building up libraries and writing them to files.</p>

<pre><code data-language='c'>/* String Functions */
lenv_add_builtin(e, "load",  builtin_load); 
lenv_add_builtin(e, "error", builtin_error);
lenv_add_builtin(e, "print", builtin_print);
</code></pre>

<pre><code data-language='lispy'>lispy&gt; print "Hello World!"
"Hello World!"
()
lispy&gt; error "This is an error"
Error: This is an error
lispy&gt; load "hello.lspy"
"Hello World!"
()
lispy&gt;
</code></pre>


<h2>Finishing Up</h2> <hr/>

<p>This is the last chapter in which we are going to explicitly work on our C implementation of Lisp. The result of this chapter will be the final state of your language implementation.</p>

<p>The final line count should clock in somewhere close to 1000 lines of code. Writing this amount of code is not trivial. If you've made it this far you've written a real program and started on a proper project. The skills you've learnt here should be transferable, and give you the confidence to seek out your own goals and targets. You now have a complex and beautiful program which you can interact and play with. This is something you should be proud of. Go show it off to your friends and family!</p>

<p>In the next chapter we start using our Lisp to build up a standard library of common functions. After that I describe some possible improvements and directions in which the language should be taken. Although we've finished with my involvement this is really this is only the beginning. Thanks for following along, and good luck with whatever C you write in the future!</p>


<h2>Reference</h2> <hr/>

<references />

<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&rsaquo; Adapt the builtin function <code>join</code> to work on strings.</li>
    <li class="list-group-item">&rsaquo; Adapt the builtin function <code>head</code> to work on strings.</li>
    <li class="list-group-item">&rsaquo; Adapt the builtin function <code>tail</code> to work on strings.</li>
    <li class="list-group-item">&rsaquo; Create a builtin function <code>read</code> that reads in and converts a string to a Q-expression.</li>
    <li class="list-group-item">&rsaquo; Create a builtin function <code>show</code> that can print the contents of strings as it is (unescaped).</li>
    <li class="list-group-item">&rsaquo; Create a special value <code>ok</code> to return instead of empty expressions <code>()</code>.</li>
    <li class="list-group-item">&rsaquo; Add functions to wrap all of C's file handling functions such as <code>fopen</code> and <code>fgets</code>.</li>
  </ul>
</div>


<h2>Navigation</h2>

<table class="table" style='table-layout: fixed;'>
  <tr>
    <td class="text-left"><a href="chapter13_conditionals"><h4>&lsaquo; Conditionals</h4></a></td>
    <td class="text-center"><a href="contents"><h4>&bull; Contents &bull;</h4></a></td>
    <td class="text-right"><a href="chapter15_standard_library"><h4>Standard Library &rsaquo;</h4></a></td>
  </tr>
</table>
