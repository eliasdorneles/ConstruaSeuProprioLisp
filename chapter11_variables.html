<h1>Variáveis <small>&bull; Capítulo 11</small></h1>


<h2>Imutabilidade</h2> <hr/>

<div class='pull-right alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/turtle.png" alt="turtle" class="img-responsive" width="279px" height="267px"/>
  <p><small>Tartarunga Ninja &bull; Não Imutável.</small></p>
</div>

<p>Nos capítulos anteriores fizemos progresso considerável na infraestrutura da nossa linguagem.</p>

<p>Já podemos fazer algumas coisas legais que outras linguagens não fazem, como colocar código dentro de listas. Agora é a hora de começar a adicionar os <em>recursos</em> que tornarão nossa linguage prática. O primeiro deles vai ser <em>variáveis</em>.</p>

<p>Elas são chamadas variávels, mas é um nome enganoso, porque nossas variáveis não irão variar. Nossas variáveis são <em>imutáveis</em>, isto é, elas não podem mudar. Tudo em nossa linguagem até agora agiu como se fosse <em>imutável</em>. Quando avaliamos uma expressão, imaginamos que a coisa anterior foi deletada e uma coisa nova foi devolvida. Na implementação, frequentemente é mais fácil reutilizarmos os dados da coisa anterior para construir a próxima coisa, mas conceitualmente é uma boa maneira de pensar a respeito de como nossa linguagem funciona.</p>

<p>Então, na verdade nossas variáveis são meramente uma maneira de <em>nomear valores</em>. Elas nos permitem atribuir um <em>nome</em> para um <em>valor</em>, e então nos deixa obter uma cópia daquele <em>valor</em> mais tarde quando precisarmos.</p>

<p>Para permitir <em>nomear valores</em>, precisamos criar uma estrutura que armazene o nome e valor de tudo que for nomeado em nosso programa. Chamamos isto de <em>ambiente</em>. Quando começamos um novo prompt interativo, queremos criar um novo ambiente para funcionar com ele, em que cada novo trecho da entrada é avaliado. A seguir podemos armazenar e relembrar variáveis enquanto programamos.</p>

<div class="alert alert-warning">
  <p><strong>O que acontece se re-atribuirmos um nome a algo novo? Isto não é o mesmo que mutabilidade?</strong></p>

  <p>No nosso Lisp, quando re-atribuímos um nome vamos deletar a associação anterior e criar uma nova. Isto dá a ilusão que a coisa atribuída àquele nome mudou e é mutável, mas de fato deletamos a coisa velha e atribuímos uma coisa nova. Isto é diferente de C onde podemos realmente mudar o dado apontado por um apontador, our armazenado em uma struct, sem deletá-la e criar uma nova.</p>
</div>


<h2>Sintaxe de Símbolo</h2> <hr/>

<p>Agora que vamos permitir nosso usuário definir variáveis, precisamos que a gramática para símbolos seja mais flexível. Em vez de apenas nossas funções builtin, ela deve casar com qualquer símbolo possível válido. Diferentemente de C, onde o nome que pode ser dado a uma variável é relativamente restringido, vamos permitir vários tipos de caracteres no nome de uma variável.</p>

<p>Podemos criar uma expressão regular que expressa a faixa de caracteres disponível como segue.</p>

<pre><code>/[a-zA-Z0-9_+\\-*\\/\\\\=&lt;&gt;!&amp;]+/</code></pre>

<p>À primeira vista, parece que simplesmente batemos com nossas mãos no teclado. Na verdade, é uma expressão regular usando um especificador de intervalo <code>[]</code>. Dentro do especificador de intervalo caracteres especiais perdem seu sentido especial, mas alguns destes caracteres ainda precisam ser escapados com barras invertidas <code>/</code>. Como isto é uma parte duma string C, precisamos colocar duas barras invertidas para representar um único caractere barra invertida na entrada.</p>

<p>Esta regra permite símbolos terem qualquer um entre os caracteres normais de identificadores C <code>a-zA-Z0-9_</code>, os caracteres de operação aritmética <code>+\\-*\\/</code>, o caractere barra invertida <code>\\\\</code>, os caracteres do operador de comparação <code>=&lt;&gt;!</code> ou um ampersand <code>&amp;</code>. Isto nos dará toda a flexibilidade que precisamos para definir símbolos novos e existentes.</p>

<pre><code data-language='C'>mpca_lang(MPCA_LANG_DEFAULT,
  "                                                     \
    number : /-?[0-9]+/ ;                               \
    symbol : /[a-zA-Z0-9_+\\-*\\/\\\\=&lt;&gt;!&amp;]+/ ;         \
    sexpr  : '(' &lt;expr&gt;* ')' ;                          \
    qexpr  : '{' &lt;expr&gt;* '}' ;                          \
    expr   : &lt;number&gt; | &lt;symbol&gt; | &lt;sexpr&gt; | &lt;qexpr&gt; ;  \
    lispy  : /^/ &lt;expr&gt;* /$/ ;                          \
  ",
  Number, Symbol, Sexpr, Qexpr, Expr, Lispy);
</code></pre>


<h2>Apontador para função</h2> <hr/>

<p>Tendo introduzido variávels, símbolos não mais representarão funções em nossa linguagem, mas um nome para buscarmos em nosso ambiente e obter um valor de volta.</p>

<p>Portanto, precisamos um novo valor para representar funções em nossa linguagem, que possamos devolver quando um dos nossos símbolos builtin seja encontrado. Para criar este novo tipo de <code>lval</code> vamos usar algo chamado um <em>apontador para função</em> (ou, ponteiro para função).</p>

<p>Apontadores para funções são um grande recurso de C que permite armazenar e repassar apontadores para funções. Não faz sentido alterar o dado apontado por estes apontadores. Em vez disso, usamo-los para chamar a função para a qual apontam, como se fossem uma função normal.</p>

<p>Como apontadores normais, apontadores para funções têm algum tipo associado à eles. Este tipo especifica o tipo da função sendo apontada, não o tipo de dado que ele aponta. Isto permite o compilador identificar se foi chamado corretamente.</p>

<p>No capítulo anterior, nossas funções builtins receberam um <code>lval*</code> como entrada e devolveram um <code>lval*</code> como saída. Neste capítulo nossas funções builtins receberão um apontador extra para o ambiente <code>lenv*</code> como entrada. Podemos declarar a nova função um novo tipo apontador de função chamado <code>lbuiltin</code>, para este tipo de função, da seguinte forma:</p>

<pre><code data-language='c'>typedef lval*(*lbuiltin)(lenv*, lval*);</code></pre>

<div class="alert alert-warning">
  <p><strong>Por que esta sintaxe tão estranha?</strong></p>

  <p>Algumas vezes a sintaxe de C pode parecer particularmente estranha. Pode ajudar se entendermos exatamente por que a sintaxe é dessa forma. Vamos desconstruir a sintaxe no exemplo acima parte por parte.</p>
  
  <p>Primeiro o <code>typedef</code>. Ele pode ser colocado antes de qualquer declaração de variável normal. Ele resulta no nome da variável, sendo declarado como um novo tipo, correspondendo ao que seria o tipo inferido para aquela variável. Por isso, na declaração acima, o que parece um nome de função se torna o nome do novo tipo.</p>
  
  <p>A seguir, todos aquelees <code>*</code>. Tipos apontadores em C foram concebidos para serem escritos com o asterisco <code>*</code> ao lado esquerdo do nome da variável, não ao lado direito do tipo <code>int *x;</code>. Isto é porque a sintaxe de tipos de C funciona com um esquema de inferência. Em vez de ler <em>"Crie um novo apontador <code>int</code> apontador x"</em>, é feita para ler <em>"Crie uma nova variável <code>x</code> onde de-referenciar <code>x</code> resulta em um <code>int</code>"</em>. Portanto, <code>x</code> é inferido como sendo um apontador para <code>int</code>.</p>
  
  <p>Esta ideia é expandida em apontadores para função. Podemos ler a declaração acima como: <em>"Para obter um <code>lval*</code>, dereferenciamos <code>lbuiltin</code> e a chamamos com um <code>lenv*</code> e um <code>lval*</code>."</em> Portanto, <code>lbuiltin</code> precisa ser um apontador para função que recebe um <code>lenv*</code> e um <code>lval*</code> e devolve um <code>lval*</code>.</p>
</div>

<h2>Tipos Cíclicos</h2> <hr/>

<p>O tipo <code>lbuiltin</code> referencia o tipo <code>lval</code> e o tipo <code>lenv</code>. Isto significa que estes devem ser declarados antes no código fonte.</p>

<p>Mas queremos fazer um campo <code>lbuiltin</code> em nossa struct <code>lval</code> para que possamos criar valores funções. Então, nossa declaração <code>lbuiltin</code> deve ir antes da nossa declaração <code>lval</code>. Isto leva ao que chamamos uma dependência cíclica de tipos, onde dois tipos dependem um do outro.</p>

<p>Nos deparamos com este problema antes com funções que dependem uma da outra. A solução foi criar uma <em>declaração adiantada</em> que declarava uma função mas deixava o corpo dela vazio.</p>

<p>Em C podemos fazer exatamente a mesma coisa com tipos. Primeiro, declaramos os dois tipos <code>struct</code> sem um corpo. Segundo, definimos com <code>typedef</code> os nomes <code>lval</code> e <code>lenv</code>. Em seguida podemos definir nosso tipo apontador para função <code>lbuiltin</code>, e finalmente podemos definir o corpo da nossa estrutura <code>lval</code>. Agora todos nossos problemas com tipos estão resolvidos e o compilador não vai reclamar mais.</p>

<pre><code data-language='c'>/* Declaracoes Adiantadas */

struct lval;
struct lenv;
typedef struct lval lval;
typedef struct lenv lenv;

/* Valor Lisp */

enum { LVAL_ERR, LVAL_NUM,   LVAL_SYM, 
       LVAL_FUN, LVAL_SEXPR, LVAL_QEXPR };

typedef lval*(*lbuiltin)(lenv*, lval*);

struct lval {
  int type;

  long num;
  char* err;
  char* sym;
  lbuiltin fun;

  int count;
  lval** cell;
};</code></pre>


<h2>Tipo Função</h2> <hr/>

<p>Como adicionamos um novo tipo possível <code>lval</code> com a enumeração <code>LVAL_FUN</code>. Devemos atualizar todas nossas funções relevantes que funcionam em <code>lvals</code> para lidar corretamente com esta atualização. Na maioria dos casos isto significa apenas inserir novos casos em comandos <code>switch</code>.</p>

<p>Podemos começar fazendo uma nova função construtora para este tipo.</p>

<pre><code data-language='c'>lval* lval_fun(lbuiltin func) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_FUN;
  v-&gt;fun = func;
  return v;
}</code></pre>

<p>Na <strong>deleção</strong> não precisamos fazer nada especial para apontadores de função.</p>

<pre><code data-language='c'>case LVAL_FUN: break;</code></pre>

<p>Na <strong>impressão</strong> podemos simplesmente imprimir uma string nominal.</p>

<pre><code data-language='c'>case LVAL_FUN:   printf("&lt;function&gt;"); break;</code></pre>

<p>Também vamos adicionar uma nova função para <strong>copiar</strong> um <code>lval</code>. Isto vai ser útil quando colocarmos e tirarmos coisas dentro do ambiente. Para números e funções podemos simplesmente copiar diretamente os campos relevantes. Para strings, precisamos copiar usando <code>malloc</code> e <code>strcpy</code>. Para copiar listas, precisamos alocar a quantidade correta de espaço e a seguir copiar cada elemento individualmente.</p>

<pre><code data-language='c'>lval* lval_copy(lval* v) {
  
  lval* x = malloc(sizeof(lval));
  x->type = v-&gt;type;
  
  switch (v-&gt;type) {
    
    /* Copy Functions and Numbers Directly */
    case LVAL_FUN: x-&gt;fun = v-&gt;fun; break;
    case LVAL_NUM: x-&gt;num = v-&gt;num; break;
    
    /* Copy Strings using malloc and strcpy */
    case LVAL_ERR:
      x-&gt;err = malloc(strlen(v-&gt;err) + 1);
      strcpy(x-&gt;err, v-&gt;err); break;
    
    case LVAL_SYM:
      x-&gt;sym = malloc(strlen(v-&gt;sym) + 1);
      strcpy(x-&gt;sym, v-&gt;sym); break;

    /* Copy Lists by copying each sub-expression */
    case LVAL_SEXPR:
    case LVAL_QEXPR:
      x-&gt;count = v-&gt;count;
      x-&gt;cell = malloc(sizeof(lval*) * x-&gt;count);
      for (int i = 0; i &lt; x-&gt;count; i++) {
        x-&gt;cell[i] = lval_copy(v-&gt;cell[i]);
      }
    break;
  }
  
  return x;
}</code></pre>


<h2>Ambiente</h2> <hr/>

<p>Nossa estrutura de ambiente precisa codificar uma lista de relacionamentos entre <em>nomes</em> e <em>valores</em>. Existem muitas maneiras de construir uma estrutura que pode fazer este tipo de coisa. Vamos usar o método mais simples possível que funciona bem. Isto é, vamos usar duas listas do mesmo tamanho. Uma é uma lista de <code>lval*</code>, e a outra é uma lista de <code>char*</code>. Cada entrada em uma lista tem um valor correspondente na outra lista na mesma posição.</p>

<p>Já declaramos adiantado nossa estrutura <code>lenv</code>, então agora podemos defini-la como segue.</p>

<pre><code data-language='c'>struct lenv {
  int count;
  char** syms;
  lval** vals;
};</code></pre>

<p>Precisamos algumas funções para criar e deletar esta estrutura. Elas são bem simples. Criação inicializa os campos do struct, enquanto a deleção itera atráves dos items em ambas listas e deleta ou libera eles.</p>

<pre><code data-language='c'>lenv* lenv_new(void) {
  lenv* e = malloc(sizeof(lenv));
  e-&gt;count = 0;
  e-&gt;syms = NULL;
  e-&gt;vals = NULL;
  return e;
}</code></pre>

<pre><code data-language='c'>void lenv_del(lenv* e) {
  for (int i = 0; i &lt; e-&gt;count; i++) {
    free(e-&gt;syms[i]);
    lval_del(e-&gt;vals[i]);
  }
  free(e-&gt;syms);
  free(e-&gt;vals);
  free(e);
}</code></pre>

<p>A seguir podemos criar duas funções que ou obtém valores do ambiente ou colocam valores nele.</p>

<p>Para obter um valor do ambiente, percorremos todos os itens no ambiente e checamos se o símbolo dado casa qualquer uma das strings armazenadas. Se achamos alguma que corresponde, podemos devolver uma cópia do valor armazenado. Se nenhum valor é encontrado, devemos retornar um erro.</p>

<p>A função para colocar novas variáveis no ambiente é um pouco mais complexa. Primeiro queremos checar se uma variável com o mesmo nome já existe. Se este for o caso, devemos substituí-la com a nova. Para fazer isso, iteramos todas as variáveis existentes no ambiente e checamos seus nomes. Se achamos uma correspondência, deletamos o valor armazenado naquela localização e armazenamos lá uma cópia do valor da entrada.</p>

<p>Se nenhum valor existente foi encontrado com esse nome, precisamos alocar mais espaço para colocá-lo. Para isso, podemos usar <code>realloc</code> e armazenar uma cópia do <code>lval</code> e seu nome nas localizações recém alocadas.</p>

<pre><code data-language='c'>lval* lenv_get(lenv* e, lval* k) {

  /* Iterate over all items in environment */
  for (int i = 0; i &lt; e-&gt;count; i++) {
    /* Check if the stored string matches the symbol string */
    /* If it does, return a copy of the value */
    if (strcmp(e-&gt;syms[i], k-&gt;sym) == 0) {
      return lval_copy(e-&gt;vals[i]);
    }
  }
  /* If no symbol found return error */
  return lval_err("unbound symbol!");
}</code></pre>

<pre><code data-language='c'>void lenv_put(lenv* e, lval* k, lval* v) {

  /* Iterate over all items in environment */
  /* This is to see if variable already exists */
  for (int i = 0; i &lt; e-&gt;count; i++) {

    /* If variable is found delete item at that position */
    /* And replace with variable supplied by user */
    if (strcmp(e-&gt;syms[i], k-&gt;sym) == 0) {
      lval_del(e-&gt;vals[i]);
      e-&gt;vals[i] = lval_copy(v);
      return;
    }
  }

  /* If no existing entry found allocate space for new entry */
  e-&gt;count++;
  e-&gt;vals = realloc(e-&gt;vals, sizeof(lval*) * e-&gt;count);
  e-&gt;syms = realloc(e-&gt;syms, sizeof(char*) * e-&gt;count);

  /* Copy contents of lval and symbol string into new location */
  e-&gt;vals[e-&gt;count-1] = lval_copy(v);
  e-&gt;syms[e-&gt;count-1] = malloc(strlen(k-&gt;sym)+1);
  strcpy(e-&gt;syms[e-&gt;count-1], k-&gt;sym);
}</code></pre>


<h2>Avaliação de Variáveis</h2> <hr/>

<p>Nossa função de avaliação agora depende de algum ambiente. Devemos passar este como um argumento e usá-lo para obter um valor se encontramos um tipo símbolo. Como nosso ambiente devolve uma cópia do valor, precisamos lembrar de deletar o símbolo de entrada <code>lval</code>.</p>

<pre><code data-language='c'>lval* lval_eval(lenv* e, lval* v) {
  if (v-&gt;type == LVAL_SYM) {
    lval* x = lenv_get(e, v);
    lval_del(v);
    return x;
  }
  if (v-&gt;type == LVAL_SEXPR) { return lval_eval_sexpr(e, v); }
  return v;
}</code></pre>

<p>Como adicionamods um tipo função, nossa avaliação de S-Expressions também precisa mudar. Em vez de checar por um tipo símbolo, queremos nos certificar que é um tipo função. Se esta condição for verdadeira, podemos chamar o campo <code>fun</code> do <code>lval</code> usando a mesma notação que as chamadas de funções normais.</p>

<pre><code data-language='c'>lval* lval_eval_sexpr(lenv* e, lval* v) {

  for (int i = 0; i &lt; v-&gt;count; i++) {
    v-&gt;cell[i] = lval_eval(e, v-&gt;cell[i]);
  }
  
  for (int i = 0; i &lt; v-&gt;count; i++) {
    if (v-&gt;cell[i]-&gt;type == LVAL_ERR) { return lval_take(v, i); }
  }

  if (v-&gt;count == 0) { return v; }  
  if (v-&gt;count == 1) { return lval_take(v, 0); }

  /* Ensure first element is a function after evaluation */
  lval* f = lval_pop(v, 0);
  if (f-&gt;type != LVAL_FUN) {
    lval_del(v); lval_del(f);
    return lval_err("first element is not a function");
  }

  /* If so call function to get result */
  lval* result = f-&gt;fun(e, v);
  lval_del(f);
  return result;
}</code></pre>


<h2>Builtins</h2> <hr/>

<p>Now that our evaluation relies on the new function type we need to make sure we can register all of our builtin functions with the environment before we start the interactive prompt. At the moment our builtin functions are not the correct type. We need to change their type signature such that they take in some environment, and where appropriate change them to pass this environment into other calls that require it. I won't post the code for this, so go ahead and change the type signatures of the buildin functions to take an <code>lenv*</code> as their first argument now. If you are confused you can look at the sample code for this chapter.</p>

<p>As an example we can make use of our <code>builtin_op</code> function to define separate builtins for each of the maths functions our language supports.</p>

<pre><code data-language='c'>lval* builtin_add(lenv* e, lval* a) {
  return builtin_op(e, a, "+");
}

lval* builtin_sub(lenv* e, lval* a) {
  return builtin_op(e, a, "-");
}

lval* builtin_mul(lenv* e, lval* a) {
  return builtin_op(e, a, "*");
}

lval* builtin_div(lenv* e, lval* a) {
  return builtin_op(e, a, "/");
}
</code></pre>

<p>Once we've changed the builtins to the correct type we can create a function that registers all of our builtins into an environment.</p>

<p>For each builtin we want to create a function <code>lval</code> and symbol <code>lval</code> with the given name. We then register these with the environment using <code>lenv_put</code>. The environment always takes or returns copies of a values, so we need to remember to delete these two <code>lval</code> after registration as we won't need them any more.</p>

<p>If we split this task into two functions we can neatly register all of our builtins with some environment.</p>

<pre><code data-language='c'>void lenv_add_builtin(lenv* e, char* name, lbuiltin func) {
  lval* k = lval_sym(name);
  lval* v = lval_fun(func);
  lenv_put(e, k, v);
  lval_del(k); lval_del(v);
}

void lenv_add_builtins(lenv* e) {  
  /* List Functions */
  lenv_add_builtin(e, "list", builtin_list);
  lenv_add_builtin(e, "head", builtin_head);
  lenv_add_builtin(e, "tail", builtin_tail);
  lenv_add_builtin(e, "eval", builtin_eval);
  lenv_add_builtin(e, "join", builtin_join);

  /* Mathematical Functions */
  lenv_add_builtin(e, "+", builtin_add);
  lenv_add_builtin(e, "-", builtin_sub);
  lenv_add_builtin(e, "*", builtin_mul);
  lenv_add_builtin(e, "/", builtin_div);
}</code></pre>

<p>The final step is to call this function before we create the interactive prompt. We also need to remember to delete the environment once we are finished.</p>

<pre><code data-language='c'>lenv* e = lenv_new();
lenv_add_builtins(e);

while (1) {

  char* input = readline("lispy&gt; ");
  add_history(input);
  
  mpc_result_t r;
  if (mpc_parse("&lt;stdin&gt;", input, Lispy, &r)) {
    
    lval* x = lval_eval(e, lval_read(r.output));
    lval_println(x);
    lval_del(x);
    
    mpc_ast_delete(r.output);
  } else {    
    mpc_err_print(r.error);
    mpc_err_delete(r.error);
  }
  
  free(input);
  
}
  
lenv_del(e);
</code></pre>

<p>If everything is working correctly we should have a play around in the prompt and verify that functions are actually a new type of value now, not symbols.</p>

<pre><code data-language='lispy'>lispy&gt; +
&lt;function&gt;
lispy&gt; eval (head {5 10 11 15})
5
lispy&gt; eval (head {+ - + - * /})
&lt;function&gt;
lispy&gt; (eval (head {+ - + - * /})) 10 20
30
lispy&gt; hello
Error: unbound symbol!
lispy&gt;</code></pre>


<h2>Define Function</h2> <hr/>

<p>We've managed to register our builtins as variables but we still don't have a way for users to define their own variables.</p>

<p>This is actually a bit awkward. We need to get the user to pass in a symbol to name, as well as the value to assign to it. But symbols can't appear on their own. Otherwise the evaluation function will attempt to retrieve a value for them from the environment.</p>

<p>The only way we can pass around symbols without them being evaluated is to put them between <code>{}</code> in a quoted expression. So we're going to use this technique for our define function. It will take as input a list of symbols, and a number of other values. It will then assign each of the values to each of the symbols.</p>

<p>This function should act like any other builtin. It first checks for error conditions and then performs some command and returns a value. In this case it first checks that the input arguments are the correct types. It then iterates over each symbol and value and puts them into the environment. If there is an error we can return it, but on success we will return the empty expression <code>()</code>.</p>

<pre><code data-language='c'>lval* builtin_def(lenv* e, lval* a) {
  LASSERT(a, a-&gt;cell[0]-&gt;type == LVAL_QEXPR,
    "Function 'def' passed incorrect type!");

  /* First argument is symbol list */
  lval* syms = a-&gt;cell[0];

  /* Ensure all elements of first list are symbols */
  for (int i = 0; i &lt; syms-&gt;count; i++) {
    LASSERT(a, syms-&gt;cell[i]-&gt;type == LVAL_SYM,
      "Function 'def' cannot define non-symbol");
  }

  /* Check correct number of symbols and values */
  LASSERT(a, syms-&gt;count == a-&gt;count-1,
    "Function 'def' cannot define incorrect "
    "number of values to symbols");

  /* Assign copies of values to symbols */
  for (int i = 0; i &lt; syms-&gt;count; i++) {
    lenv_put(e, syms-&gt;cell[i], a-&gt;cell[i+1]);
  }

  lval_del(a);
  return lval_sexpr();
}</code></pre>

<p>We need to register this new builtin using our builtin function <code>lenv_add_builtins</code>.</p>

<pre><code data-language='c'>/* Variable Functions */
lenv_add_builtin(e, "def",  builtin_def);</code></pre>

<p>Now we should be able to support user defined variables. Because our <code>def</code> function takes in a list of symbols we can do some cool things storing and manipulating symbols in lists before passing them to be defined. Have a play around in the prompt and ensure everything is working correctly. You should get behaviour as follows. Explore what other complex methods are possible for the definition and evaluation of variables. Once we get to defining functions we'll really see some of the useful things that can be done with this approach.</p>

<pre><code data-language='lispy'>lispy&gt; def {x} 100
()
lispy&gt; def {y} 200
()
lispy&gt; x
100
lispy&gt; y
200
lispy&gt; + x y
300
lispy&gt; def {a b} 5 6
()
lispy&gt; + a b
11
lispy&gt; def {arglist} {a b x y}
()
lispy&gt; arglist
{a b x y}
lispy&gt; def arglist 1 2 3 4
()
lispy&gt; list a b x y
{1 2 3 4}
lispy&gt;</code></pre>


<h2>Error Reporting</h2> <hr/>

<p>So far our error reporting doesn't work so well. We can report when an error occurs, and give a vague notion of what the problem was, but we don't give the user much information about what exactly has gone wrong. For example if there is an unbound symbol we should be able to report exactly which symbol was unbound. This can help the user track down errors, typos, and other trivial problems.</p>

<div class='pull-left alert alert-warning' style="margin: 15px; text-align: center;">
  <img src="/static/img/eclipses.png" alt="eclipses" class="img-responsive" width="315px" height="246px"/>
  <p><small>Eclipses &bull; Like ellipsis.</small></p>
</div>

<p>Wouldn't it be great if we could write a function that can report errors in a similar way to how <code>printf</code> works. It would be ideal if we could pass in strings, integers, and other data to make our error messages richer.</p>

<p>The <code>printf</code> function is a special function in C because it takes a variable number of arguments. We can create our own <em>variable argument</em> functions, which is what we're going to do to make our error reporting better.</p>

<p>We'll modify <code>lval_err</code> to act in the same way as <code>printf</code>, taking in a format string, and after that a variable number of arguments to match into this string.</p>

<p>To declare that a function takes variables arguments in the type signature you use the special syntax of ellipsis <code>...</code>, which represent the rest of the arguments.</p>

<pre><code data-language='c'>lval* lval_err(char* fmt, ...);</code></pre>

<p>Then, inside the function there are standard library functions we can use to examine what the caller has passed in.</p>

<p>The first step is to create a <code>va_list</code> struct and initialise it with <code>va_start</code>, passing in the last named argument. For other purposes it is possible to examine each argument passed in using <code>va_arg</code>, but we are going to pass our whole variable argument list directly to the <code>vsnprintf</code> function. This function acts like <code>printf</code> but instead writes to a string and takes in a <code>va_list</code>. Once we are done with our variable arguments, we shoulder call <code>va_end</code> to cleanup any resources used.</p>

<p>The <code>vsnprintf</code> function outputs to a string, which we need to allocate some first. Because we don't know the size of this string until we've run the function we first allocate a buffer <code>512</code> characters big and then reallocate to a smaller buffer once we've output to it. If an error message is going to be longer than 512 characters it will just get cut off, but hopefully this won't happen.</p>

<p>Putting it all together our new error function looks like this.</p>

<pre><code data-language='c'>lval* lval_err(char* fmt, ...) {
  lval* v = malloc(sizeof(lval));
  v-&gt;type = LVAL_ERR;

  /* Create a va list and initialize it */
  va_list va;
  va_start(va, fmt);

  /* Allocate 512 bytes of space */
  v-&gt;err = malloc(512);

  /* printf the error string with a maximum of 511 characters */
  vsnprintf(v-&gt;err, 511, fmt, va);

  /* Reallocate to number of bytes actually used */
  v-&gt;err = realloc(v-&gt;err, strlen(v-&gt;err)+1);

  /* Cleanup our va list */
  va_end(va);

  return v;
}</code></pre>

<p>Using this we can then start adding in some better error messages to our functions. As an example we can look at <code>lenv_get</code>. When a symbol can't be found, rather than reporting a generic error, we can actually report the name that was not found.</p>

<pre><code data-language='c'>return lval_err("Unbound Symbol '%s'", k-&gt;sym);</code></pre>

<p>We can also adapt our <code>LASSERT</code> macro such that it can take variable arguments too. Because this is a macro and not a standard function the syntax is slightly different. On the left hand side of the definition we use the ellipses notation again, but on the right hand side we use a special variable <code>__VA_ARGS__</code> to paste in the contents of all the other arguments.</p>

<p>We need to prefix this special variable with two hash signs <code>##</code>. This ensures that it is pasted correctly when the macro is passed no extra arguments. In essence what this does is make sure to remove the leading comma <code>,</code> to appear as if no extra arguments were passed in.</p>

<p>Because we might use <code>args</code> in the construction of the error message we need to make sure we don't delete it until we've created the error value.</p>

<pre><code data-language='c'>#define LASSERT(args, cond, fmt, ...) \
  if (!(cond)) { \
    lval* err = lval_err(fmt, ##__VA_ARGS__); \
    lval_del(args); \
    return err; \
  }</code></pre>

<p>Now we can update some of our error messages to make them more informative. For example if the incorrect number of arguments were passed we can specify how many were required and how many were given.</p>

<pre><code data-language='c'>LASSERT(a, a-&gt;count == 1,
  "Function 'head' passed too many arguments. "
  "Got %i, Expected %i.",
  a-&gt;count, 1);</code></pre>

<p>We can also improve our error reporting for type errors. We should attempt to report what type was expected by a function and what type it actually got. Before we can do this it would be useful to have a function that took as input some type enumeration and returned a string representation of that type.</p>

<pre><code data-language='c'>char* ltype_name(int t) {
  switch(t) {
    case LVAL_FUN: return "Function";
    case LVAL_NUM: return "Number";
    case LVAL_ERR: return "Error";
    case LVAL_SYM: return "Symbol";
    case LVAL_SEXPR: return "S-Expression";
    case LVAL_QEXPR: return "Q-Expression";
    default: return "Unknown";
  }
}</code></pre>

<pre><code data-language='c'>LASSERT(a, a-&gt;cell[0]-&gt;type == LVAL_QEXPR, 
  "Function 'head' passed incorrect type for argument 0. "
  "Got %s, Expected %s.",
  ltype_name(a-&gt;cell[0]-&gt;type), ltype_name(LVAL_QEXPR));
</code></pre>

<p>Go ahead and use <code>LASSERT</code> to report errors in greater depth throughout the code. This should make debugging many of the next stages much easier as we begin to write complicated code using our new language. See if you can use macros to save on typing and automatically generate code for common methods of error reporting.</p>

<pre><code data-language='lispy'>lispy&gt; + 1 {5 6 7}
Error: Function '+' passed incorrect type for argument 1. Got Q-Expression, Expected Number.
lispy&gt; head {1 2 3} {4 5 6}
Error: Function 'head' passed incorrect number of arguments. Got 2, Expected 1.
lispy&gt;</code></pre>


<h2>Reference</h2> <hr/>

<references />

<h2>Bonus Marks</h2> <hr/>

<div class="alert alert-warning">
  <ul class="list-group">
    <li class="list-group-item">&rsaquo; Create a Macro to aid specifically with reporting type errors.</li>
    <li class="list-group-item">&rsaquo; Create a Macro to aid specifically with reporting argument count errors.</li>
    <li class="list-group-item">&rsaquo; Create a Macro to aid specifically with reporting empty list errors.</li>
    <li class="list-group-item">&rsaquo; Change printing a builtin function so that it prints its name.</li>
    <li class="list-group-item">&rsaquo; Write a function for printing out all the named values in an environment.</li>
    <li class="list-group-item">&rsaquo; Redefine one of the builtin variables to something different.</li>
    <li class="list-group-item">&rsaquo; Change redefinition of one of the builtin variables to something different an error.</li>
    <li class="list-group-item">&rsaquo; Create an <code>exit</code> function for stopping the prompt and exiting.</li>
  </ul>
</div>


<h2>Navigation</h2>

<table class="table" style='table-layout: fixed;'>
  <tr>
    <td class="text-left"><a href="chapter10_q_expressions"><h4>&lsaquo; Q-Expressions</h4></a></td>
    <td class="text-center"><a href="contents"><h4>&bull; Contents &bull;</h4></a></td>
    <td class="text-right"><a href="chapter12_functions"><h4>Functions &rsaquo;</h4></a></td>
  </tr>
</table>
